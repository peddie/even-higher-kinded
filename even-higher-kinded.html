<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Matt Peddie, Kittyhawk mpeddie@gmail.com" />
  <meta name="date" content="2019-01-15" />
  <title>Real-world applications for even higher-kinded data types</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Real-world applications for even higher-kinded data types</h1>
  <p class="author">
Matt Peddie, Kittyhawk <a href="mailto:mpeddie@gmail.com">mpeddie@gmail.com</a>
  </p>
  <p class="date">15 January 2019</p>
</div>
<div class="slide section level1">

<?xml version='1.0' encoding='UTF-8'?>
<!-- This file was generated by dvisvgm 1.15.1 -->
<svg height="0pt" version="1.1" viewBox="0 0 0 0" width="0pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id='page1' transform='matrix(1.13 0 0 1.13 0 0)'/>
</svg>
</div>
<div id="apologies-in-advance" class="slide section level1">
<h1>Apologies in advance</h1>
<p>This is not a beginner-level talk, and I don’t have time in 15 minutes to go over the basics.</p>
<p>We’re going to talk about some types with complicated kinds. The messages I want to convey are:</p>
<ul>
<li><p>Types with complex kinds can arise naturally in real-world situations.</p></li>
<li><p>Factoring out the components of large, nested types can illuminate useful structural patterns in spite of the fact that the kinds get hairier.</p></li>
<li><p>The existing standard library still provides a good guide for figuring out the right abstractions.</p></li>
</ul>
</div>
<div id="kinds" class="slide section level1">
<h1>Kinds</h1>
<pre><code>Int    :: *
Maybe  :: * -&gt; *
Either :: * -&gt; * -&gt; *
???    :: (* -&gt; *) -&gt; *</code></pre>
</div>
<div id="higher-kinded-structures-from-last-time" class="slide section level1">
<h1>Higher-kinded structures (from last time)</h1>
<pre><code>data X f = MakeMeAnX (f Word)

f :: (* -&gt; *)
X :: (* -&gt; *) -&gt; *</code></pre>
</div>
<div id="application-from-last-time" class="slide section level1">
<h1>Application (from last time)</h1>
<p>C code generation:</p>
<pre><code>type CGPrimitives = &#39;[Bool, Int8, . . ., Double]</code></pre>
<!-- -->
<pre><code>data PrimitiveCollection f = PrimitiveCollection
    { primCollBool :: f Bool
    , primCollInt16 :: f Int16
    . . .
    , primCollDouble :: f Double
    }</code></pre>
<p>where <code>f :: * -&gt; *</code> is a type that allows us to either evaluate or code-generate. It gives us a typed DSL.</p>
</div>
<div id="abstractions-from-last-time" class="slide section level1">
<h1>Abstractions (from last time)</h1>
<pre><code>class HK1Functor x where
    type HK1Constraint x a :: Constraint

    fmapHK1 :: (forall a. HK1Constraint x a =&gt; f a -&gt; g a)
            -&gt; x f
            -&gt; x g

class HK1Functor x =&gt; HK1Traverse x where
    traverseHK1 :: Applicative m
                =&gt; (forall a. HK1Constraint x a =&gt; f a -&gt; m (g a))
                -&gt; x f
                -&gt; m (x g)

newtype HK1Function x f g a =
  HK1Function { runHK1Function :: HK1Constraint x a =&gt; f a -&gt; g a }

class HK1Functor x =&gt; HK1Apply x where
  apHK1 :: x (HK1Function x f g) -&gt; x f -&gt; x g</code></pre>
<p>Akin perhaps to either a <code>Naperian</code> functor or a <code>Representable</code> functor, if the <code>HK1Constraint</code> is sufficiently uninteresting.</p>
</div>
<div id="new-application-heterogeneous-sensor-processing" class="slide section level1">
<h1>New application: heterogeneous sensor processing</h1>
<p>Uniform processing of heterogeneous collections: sensor inputs to flight controller.</p>
<pre><code>data PitotTube f = PitotTube
  { staticPort :: f Double
  , stagnationPort :: f Double
  }

data Magnetometer f = Magnetometer
  { bfieldX :: f Double
  , bfieldY :: f Double
  , bfieldZ :: f Double
  }</code></pre>
</div>
<div id="new-application-heterogeneous-sensor-processing-1" class="slide section level1">
<h1>New application: heterogeneous sensor processing</h1>
<h3 id="many-processing-steps">Many processing steps:</h3>
<ul>
<li>ensure that we got a new measurement (or report an error)</li>
<li>filter out outliers</li>
<li>flag any unexpected conditions</li>
<li>update estimate</li>
<li>collect statistics</li>
</ul>
</div>
<div id="new-application-heterogeneous-sensor-processing-2" class="slide section level1">
<h1>New application: heterogeneous sensor processing</h1>
<h3 id="many-processing-steps-1">Many processing steps:</h3>
<ul>
<li>ensure that we got a new measurement (or report an error)</li>
<li>filter out outliers</li>
<li>flag any unexpected conditions</li>
<li>update estimate</li>
<li>collect statistics</li>
</ul>
<h3 id="goals-when-adding-or-removing-a-sensor">Goals when adding or removing a sensor:</h3>
<ul>
<li>should only have to touch code related to that sensor</li>
<li>compiler should constrain us to the correct processing path (we can’t forget any steps)</li>
</ul>
</div>
<div id="excelsior" class="slide section level1">
<h1>Excelsior</h1>
<pre><code>{-# LANGUAGE KindSignatures, ConstraintKinds, TypeFamilies, RankNTypes #-}</code></pre>
<p>Write one type specifying all the sensors on the aircraft.</p>
<pre><code>data Sensors (s:: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Sensors
  { sensorsPitot        :: s PitotTube f
  , sensorsMagnetometer :: s Magnetometer f
  }</code></pre>
</div>
<div id="excelsior-1" class="slide section level1">
<h1>Excelsior</h1>
<pre><code>{-# LANGUAGE KindSignatures, ConstraintKinds, TypeFamilies, RankNTypes #-}</code></pre>
<p>Write one type specifying all the sensors on the aircraft.</p>
<pre><code>data Sensors (s:: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Sensors
  { sensorsPitot        :: s PitotTube f
  , sensorsMagnetometer :: s Magnetometer f
  }</code></pre>
<p>Example type for s:</p>
<pre><code>data Timestamp (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Timestamp
  { timestampMeasurement :: x f
  , timestampEpoch       :: f Double
  }</code></pre>
</div>
<div id="excelsior-2" class="slide section level1">
<h1>Excelsior</h1>
<pre><code>{-# LANGUAGE KindSignatures, ConstraintKinds, TypeFamilies, RankNTypes #-}</code></pre>
<p>Write one type specifying all the sensors on the aircraft.</p>
<pre><code>data Sensors (s:: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Sensors
  { sensorsPitot        :: s PitotTube f
  , sensorsMagnetometer :: s Magnetometer f
  }</code></pre>
<p>Example type for s:</p>
<pre><code>data Timestamp (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Timestamp
  { timestampMeasurement :: x f
  , timestampEpoch       :: f Double
  }</code></pre>
<p>The kinds are even higher:</p>
<pre><code>x       ::                                       (* -&gt; *) -&gt; *  -- HK1
s       :: ((* -&gt; *) -&gt; *)  -&gt;                   (* -&gt; *) -&gt; *  -- HK2
Sensors :: (((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *  -- HK3</code></pre>
</div>
<div id="excelsior-3" class="slide section level1">
<h1>Excelsior</h1>
<pre><code>{-# LANGUAGE KindSignatures, ConstraintKinds, TypeFamilies, RankNTypes #-}</code></pre>
<p>Write one type specifying all the sensors on the aircraft.</p>
<pre><code>data Sensors (s:: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Sensors
  { sensorsPitot        :: s PitotTube f
  , sensorsMagnetometer :: s Magnetometer f
  }</code></pre>
<p>Example type for s:</p>
<pre><code>data Timestamp (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Timestamp
  { timestampMeasurement :: x f
  , timestampEpoch       :: f Double
  }</code></pre>
<p>The kinds are even higher:</p>
<pre><code>x       ::                                       (* -&gt; *) -&gt; *  -- HK1
s       :: ((* -&gt; *) -&gt; *)  -&gt;                   (* -&gt; *) -&gt; *  -- HK2
Sensors :: (((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *  -- HK3</code></pre>
<p>Conjecture: if we can write all the sensor processing steps as operations on <code>Sensors</code>, and find a way to connect all the corresponding pieces (individual steps for individual sensors) together in a way that doesn’t let us leave anything out, we can meet the requirements.</p>
</div>
<div id="application-latest-measurement-time" class="slide section level1">
<h1>Application: latest measurement time</h1>
<p>Get latest measurement time for all sensors.</p>
<pre><code>newtype ConstHK2 a (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = ConstHK2 { getConstHK2 :: a }

getLatestMeasurementTime :: Sensors Timestamp f -&gt; Sensors (ConstHK2 (f Double)) f</code></pre>
</div>
<div id="application-latest-measurement-time-1" class="slide section level1">
<h1>Application: latest measurement time</h1>
<p>Get latest measurement time for all sensors.</p>
<pre><code>newtype ConstHK2 a (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = ConstHK2 { getConstHK2 :: a }

getLatestMeasurementTime :: Sensors Timestamp f -&gt; Sensors (ConstHK2 (f Double)) f</code></pre>
<p>This looks suspiciously familiar:</p>
<pre><code>class HK3Functor (v :: (((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) where
  type HK3Constraint v (f :: * -&gt; *) (x :: (* -&gt; *) -&gt; *) :: Constraint

  fmapHK3 :: (forall x. HK3Constraint v f x =&gt; g x f -&gt; h x f) -&gt; v g f -&gt; v h f

instance HK3Functor Sensors where
  type HK3Constraint Sensors f x = &lt;various constraints&gt;

  fmapHK3 f (Sensors oldPitot oldMagnetometer) = Sensors
      { sensorsPitot        = f oldPitot
      , sensorsMagnetometer = f oldMagnetometer
      }</code></pre>
</div>
<div id="application-latest-measurement-time-2" class="slide section level1">
<h1>Application: latest measurement time</h1>
<p>Get latest measurement time for all sensors.</p>
<pre><code>class HK3Functor (v :: (((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) where
  type HK3Constraint v (f :: * -&gt; *) (x :: (* -&gt; *) -&gt; *) :: Constraint

  fmapHK3 :: (forall x. HK3Constraint v f x =&gt; g x f -&gt; h x f) -&gt; v g f -&gt; v h f

instance HK3Functor Sensors where
  type HK3Constraint Sensors f x = &lt;various constraints&gt;

  fmapHK3 f (Sensors oldPitot oldMagnetometer) = Sensors
      { sensorsPitot        = f oldPitot
      , sensorsMagnetometer = f oldMagnetometer
      }</code></pre>
<p>Now:</p>
<pre><code>getLatestMeasurementTime :: Sensors Timestamp f -&gt; Sensors (ConstHK2 (f Double)) f
getLatestMeasurementTime = fmapHK3 (ConstHK2 . timestampEpoch)</code></pre>
</div>
<div id="application-latest-measurement-time-3" class="slide section level1">
<h1>Application: latest measurement time</h1>
<p>Check against the requirements:</p>
<ul>
<li>only write the code necessary for each sensor
<ul>
<li>add field to <code>instance HK3Functor</code></li>
</ul></li>
<li>compiler should prevent us from forgetting any processing steps
<ul>
<li>type error if timestamp isn’t passed in!</li>
</ul></li>
</ul>
</div>
<div id="application-checksum-validation" class="slide section level1">
<h1>Application: checksum validation</h1>
<p>Collect checksum errors from all sensor measurements.</p>
<pre><code>newtype ComposeHK2
  (s :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (t :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (x :: (* -&gt; *) -&gt; *)
  (f :: * -&gt; *)
  = ComposeHK2 { getComposeHK2 :: s (t x) f }

data Checksum (x :: (* -&gt; *) -&gt; *) (f :: * -&gt; *) = Checksum
  { checksumCRC32 :: f Word32
  , checksumData  :: x f
  }

checksumVerify :: Sensors (ComposeHK2 Checksum Timestamp) f
               -&gt; Validation [SensorError] (Sensors Timestamp f)</code></pre>
</div>
<div id="application-checksum-validation-1" class="slide section level1">
<h1>Application: checksum validation</h1>
<pre><code>checksumVerify :: Sensors (ComposeHK2 Checksum Timestamp) f
               -&gt; Validation [SensorError] (Sensors Timestamp f)</code></pre>
<p>This looks awfully familiar as well.</p>
<pre><code>class HK3Functor v =&gt; HK3Traversable v where
  traverseHK3 :: Applicative m
              =&gt; (forall x. HK3Constraint v f x =&gt; g x f -&gt; m (h x f))
              -&gt; v g f
              -&gt; m (v h f)

instance HK3Traversable Sensors where
  traverseHK3 f (Sensors oldPitot oldMagnetometer) =
    Sensors &lt;$&gt; f oldPitot &lt;*&gt; f oldMagnetometer</code></pre>
</div>
<div id="application-checksum-validation-2" class="slide section level1">
<h1>Application: checksum validation</h1>
<pre><code>checksumVerify :: Sensors (ComposeHK2 Checksum Timestamp) f
               -&gt; Validation [SensorError] (Sensors Timestamp f)</code></pre>
<p>This looks awfully familiar as well.</p>
<pre><code>class HK3Functor v =&gt; HK3Traversable v where
  traverseHK3 :: Applicative m
              =&gt; (forall x. HK3Constraint v f x =&gt; g x f -&gt; m (h x f))
              -&gt; v g f
              -&gt; m (v h f)

instance HK3Traversable Sensors where
  traverseHK3 f (Sensors oldPitot oldMagnetometer) =
    Sensors &lt;$&gt; f oldPitot &lt;*&gt; f oldMagnetometer</code></pre>
<p>In this case, we must use a helper type class (<code>CRC32able</code>) to operate uniformly on different measurements.</p>
<pre><code>  type HK3Constraint Sensors f x = CRC32able (x f)</code></pre>
</div>
<div id="application-checksum-validation-3" class="slide section level1">
<h1>Application: checksum validation</h1>
<pre><code>checksumVerify :: Sensors (ComposeHK2 Checksum Timestamp) f
               -&gt; Validation [SensorError] (Sensors Timestamp f)
checksumVerify = traverseHK3 go
  where
    go (ComposeHK2 cksummed) =
      validate someError
      (\tsMeas -&gt; checksumCRC32 cksummed .== crc32 tsMeas)
      (checksumData cksummed)</code></pre>
</div>
<div id="application-checksum-validation-4" class="slide section level1">
<h1>Application: checksum validation</h1>
<p>Check against the requirements:</p>
<ul>
<li>only write the code necessary for each sensor
<ul>
<li><code>instance CRC32able a</code></li>
<li>add field to <code>instance HK3Traversable Sensors</code></li>
</ul></li>
<li>compiler should prevent us from forgetting any processing steps
<ul>
<li>compile error if no <code>CRC32able</code> instance is provided!</li>
</ul></li>
</ul>
</div>
<div id="application-stateful-filtering" class="slide section level1">
<h1>Application: stateful filtering</h1>
<p>Stateful filtering of sensor measurements.</p>
<pre><code>class SensorMeasurement x where
  type FilterState  x (f :: * -&gt; *) :: *
  type FilterConfig x (f :: * -&gt; *) :: *
  type Estimate     x (f :: * -&gt; *) :: *

  filterStep :: FilterConfig x f                        -- ^ Config settings
             -&gt; FilterState x f                         -- ^ previous state
             -&gt; x f                                     -- ^ latest measurement
             -&gt; (FilterState x f, Estimate x f)         -- ^ Resulting estimate and next state</code></pre>
<p>NB: cannot partially apply type synonyms.</p>
</div>
<div id="application-stateful-filtering-1" class="slide section level1">
<h1>Application: stateful filtering</h1>
<p>Stateful filtering of sensor measurements.</p>
<pre><code>class SensorMeasurement x where
  type FilterState  x (f :: * -&gt; *) :: *
  type FilterConfig x (f :: * -&gt; *) :: *
  type Estimate     x (f :: * -&gt; *) :: *

  filterStep :: FilterConfig x f                        -- ^ Config settings
             -&gt; FilterState x f                         -- ^ previous state
             -&gt; x f                                     -- ^ latest measurement
             -&gt; (FilterState x f, Estimate x f)         -- ^ Resulting estimate and next state</code></pre>
<p>NB: cannot partially apply type synonyms.</p>
<pre><code>newtype FilterStateF x f  = FilterStateF { getFilterStateF :: FilterState x f }
newtype FilterConfigF x f = FilterConfigF { getFilterConfigF :: FilterConfig x f }
newtype EstimateF x f     = EstimateF { getEstimateF :: Estimate x f }</code></pre>
<!--  -->
<pre><code>  type HK3Constraint Sensors f x = (CRC32able (x f), SensorMeasurement x)

filterSensors :: Sensors FilterConfigF f
              -&gt; Sensors FilterStateF f
              -&gt; Sensors Timestamp f
              -&gt; Sensors (Product2 FilterStateF EstimateF) f</code></pre>
</div>
<div id="application-stateful-filtering-2" class="slide section level1">
<h1>Application: stateful filtering</h1>
<p>Let’s let the standard library guide the way again. A multi-argument function applied in context?</p>
<pre><code>newtype HK3Function
  (v :: (((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (g :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (h :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (x :: (* -&gt; *) -&gt; *)
  (f :: * -&gt; *) = HK3Function
  { runHK3Function :: HK3Constraint v f x =&gt; g x f -&gt; h x f }

class HK3Functor v =&gt; HK3Apply v where
  apHK3 :: v (HK3Function v g h) f -&gt; v g f -&gt; v h f

instance HK3Apply Sensors where
  apHK3 f x = Sensors
    { sensorsPitot        = runHK3Function (sensorsPitot f) $ sensorsPitot x
    , sensorsMagnetometer = runHK3Function (sensorsMagnetometer f) $ sensorsMagnetometer x
    }</code></pre>
</div>
<div id="application-stateful-filtering-3" class="slide section level1">
<h1>Application: stateful filtering</h1>
<pre><code>{-# LANGUAGE ScopedTypeVariables #-}

zipWith3HK3 :: forall v g h j k f. HK3Apply v
          =&gt; (forall x. HK3Constraint v f x =&gt; g x f -&gt; h x f -&gt; j x f -&gt; k x f)
          -&gt; v g f -&gt; v h f -&gt; v j f -&gt; v k f
zipWith3HK3 f vgf vhf vjf =
  fmapHK3 wrap vgf `apHK3` vhf `apHK3` vjf
  where
    wrap :: g x f -&gt; HK3Function v h (HK3Function v j k) x f
    wrap gxfs = HK3Function $ \hxfs -&gt; HK3Function $ f gxfs hxfs</code></pre>
</div>
<div id="application-stateful-filtering-4" class="slide section level1">
<h1>Application: stateful filtering</h1>
<pre><code>{-# LANGUAGE ScopedTypeVariables #-}

zipWith3HK3 :: forall v g h j k f. HK3Apply v
          =&gt; (forall x. HK3Constraint v f x =&gt; g x f -&gt; h x f -&gt; j x f -&gt; k x f)
          -&gt; v g f -&gt; v h f -&gt; v j f -&gt; v k f
zipWith3HK3 f vgf vhf vjf =
  fmapHK3 wrap vgf `apHK3` vhf `apHK3` vjf
  where
    wrap :: g x f -&gt; HK3Function v h (HK3Function v j k) x f
    wrap gxfs = HK3Function $ \hxfs -&gt; HK3Function $ f gxfs hxfs</code></pre>
<!--  -->
<pre><code>data Product2
  (g :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (h :: ((* -&gt; *) -&gt; *) -&gt; (* -&gt; *) -&gt; *)
  (x :: (* -&gt; *) -&gt; *)
  (f :: * -&gt; *) = Pair2
  { pair2Left :: g x f
  , pair2Right :: h x f
  }</code></pre>
</div>
<div id="application-stateful-filtering-5" class="slide section level1">
<h1>Application: stateful filtering</h1>
<pre><code>filterSensors :: Sensors FilterConfigF f
              -&gt; Sensors FilterStateF f
              -&gt; Sensors Timestamp f
              -&gt; Sensors (Product2 FilterStateF EstimateF) f
filterSensors = zipWith3HK3 go
  where
    go (FilterConfigF config) (FilterStateF oldState) (Timestamp meas _) =
      let (newState, estimate) = filterStep config oldState meas in
        Pair2 (FilterStateF newState) (EstimateF estimate)</code></pre>
</div>
<div id="application-stateful-filtering-6" class="slide section level1">
<h1>Application: stateful filtering</h1>
<pre><code>filterSensors :: Sensors FilterConfigF f
              -&gt; Sensors FilterStateF f
              -&gt; Sensors Timestamp f
              -&gt; Sensors (Product2 FilterStateF EstimateF) f
filterSensors = zipWith3HK3 go
  where
    go (FilterConfigF config) (FilterStateF oldState) (Timestamp meas _) =
      let (newState, estimate) = filterStep config oldState meas in
        Pair2 (FilterStateF newState) (EstimateF estimate)</code></pre>
<!--  -->
<pre><code>getStates = fmapHK3 pair2Left

getEstimates = fmapHK3 pair2Right</code></pre>
</div>
<div id="application-stateful-filtering-7" class="slide section level1">
<h1>Application: stateful filtering</h1>
<p>Check against the requirements:</p>
<ul>
<li>only write the code necessary for each sensor
<ul>
<li><code>instance SensorMeasurement a</code> (including associated type synonyms)</li>
<li>no defaults in type class</li>
<li>add field to <code>instance HK3Apply Sensors</code></li>
</ul></li>
<li>compiler should prevent us from forgetting any processing steps
<ul>
<li>compile error if no <code>SensorMeasurement</code> instance is provided!</li>
</ul></li>
</ul>
</div>
<div id="limitations" class="slide section level1">
<h1>Limitations</h1>
<p>Many standard classes will not deal well with this kind of code.</p>
<p>You may need to create your own “lifted” versions of standard type classes (or upgrade to GHC 8.6 and play with <code>-XQuantifiedConstraints</code>).</p>
<p>This may look like the oft-discussed “existential anti-pattern,” but notice that unlike e.g. <code>data CRC32Data = forall a. CRC32Data a =&gt; CRC32Data a</code>, we <strong>never lose or hide type information</strong> and always operate over a well-defined structure.</p>
<p>You could write something analogous with <code>HList</code>, but to me it seems easier to understand the code when it’s all based around one central type, instead of each operation specifying the necessary constraints on the <code>HList</code>.</p>
</div>
<div id="future-work" class="slide section level1">
<h1>Future work</h1>
<p>My conclusion so far is “don’t panic; find analogies to the standard library and you can get pretty far just by turning the crank.”</p>
<p>Ideally these classes could be defined without referring to <code>f</code> all the way through, but then you deal with even more <code>newtype</code>-wrapping and unwrapping everywhere.</p>
<p>I would like to understand more about what’s going on here, so if you know more about any of these topics and/or are interested in what I just showed, please come chat with me (or hit up <code>peddie</code> on <code>#bfpg</code>).</p>
</div>
</body>
</html>
